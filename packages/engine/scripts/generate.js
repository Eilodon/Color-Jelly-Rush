// packages/engine/scripts/generate.js
/**
 * EIDOLON-V GENESIS - Code Generator
 * Generates TypeScript code from schema definition.
 * 
 * Usage: node packages/engine/scripts/generate.js
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { SCHEMA } from './schema.config.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const OUTPUT_DIR = path.join(__dirname, '../src/generated');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR, { recursive: true });

// Type Mapping Configuration
const TYPE_MAP = {
    'f32': { array: 'Float32Array', bytes: 4, view: 'getFloat32', set: 'setFloat32' },
    'u32': { array: 'Uint32Array', bytes: 4, view: 'getUint32', set: 'setUint32' },
    'i32': { array: 'Int32Array', bytes: 4, view: 'getInt32', set: 'setInt32' },
    'u16': { array: 'Uint16Array', bytes: 2, view: 'getUint16', set: 'setUint16' },
    'u8': { array: 'Uint8Array', bytes: 1, view: 'getUint8', set: 'setUint8' },
};

function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
}

function generate() {
    console.log('âš¡ Eidolon-V Genesis: Generating Core Engine...');

    const timestamp = new Date().toISOString();

    // =========================================================================
    // WORLD STATE
    // =========================================================================
    let worldStateCode = `/**
 * AUTO-GENERATED by EIDOLON-V GENESIS - DO NOT EDIT MANUALLY
 * Generated: ${timestamp}
 * Source: packages/engine/scripts/schema.config.js
 */

export const MAX_ENTITIES = 10000;

export interface IWorldConfig {
    maxEntities?: number;
}

export class WorldState {
    public readonly maxEntities: number;
    
    // Entity State Flags (ACTIVE, DEAD, etc.)
    public readonly stateFlags: Uint8Array;
    
    // Component Buffers
`;

    // =========================================================================
    // ACCESSOR CLASSES
    // =========================================================================
    let accessorCode = `/**
 * AUTO-GENERATED by EIDOLON-V GENESIS - DO NOT EDIT MANUALLY
 * Generated: ${timestamp}
 */

import type { WorldState } from './WorldState';

// Entity State Flags
export const enum EntityFlags {
    ACTIVE = 0x01,
    DEAD = 0x02,
    PLAYER = 0x04,
    BOT = 0x08,
    FOOD = 0x10,
    PROJECTILE = 0x20,
    BOSS = 0x40,
    LOCAL = 0x80,
}

// =============================================================================
// STATE ACCESSOR (Special - uses Uint8Array directly)
// =============================================================================

export class StateAccess {
    static isActive(world: WorldState, id: number): boolean {
        return (world.stateFlags[id] & EntityFlags.ACTIVE) !== 0;
    }

    static isDead(world: WorldState, id: number): boolean {
        return (world.stateFlags[id] & EntityFlags.DEAD) !== 0;
    }

    static setFlag(world: WorldState, id: number, flag: number): void {
        world.stateFlags[id] |= flag;
    }

    static clearFlag(world: WorldState, id: number, flag: number): void {
        world.stateFlags[id] &= ~flag;
    }

    static hasFlag(world: WorldState, id: number, flag: number): boolean {
        return (world.stateFlags[id] & flag) !== 0;
    }

    static getFlags(world: WorldState, id: number): number {
        return world.stateFlags[id];
    }

    static setFlags(world: WorldState, id: number, flags: number): void {
        world.stateFlags[id] = flags;
    }

    static activate(world: WorldState, id: number): void {
        world.stateFlags[id] |= EntityFlags.ACTIVE;
    }

    static deactivate(world: WorldState, id: number): void {
        world.stateFlags[id] &= ~EntityFlags.ACTIVE;
    }

    static markDead(world: WorldState, id: number): void {
        world.stateFlags[id] |= EntityFlags.DEAD;
    }
}

`;

    // =========================================================================
    // NETWORK PACKER
    // =========================================================================
    let packerCode = `/**
 * AUTO-GENERATED by EIDOLON-V GENESIS - DO NOT EDIT MANUALLY
 * Network Serialization - Packet matches Memory Layout exactly
 * Generated: ${timestamp}
 */

import type { WorldState } from './WorldState';

export const COMPONENT_IDS = {
`;

    let packerBody = `
export class NetworkSerializer {
    /**
     * Pack a single entity's component into a DataView
     * @returns New offset after writing
     */
    static packEntityComponent(
        world: WorldState, 
        id: number, 
        componentId: number, 
        view: DataView, 
        offset: number
    ): number {
        switch (componentId) {
`;

    let unpackerBody = '';

    // =========================================================================
    // GENERATE FOR EACH COMPONENT
    // =========================================================================
    const componentMeta = [];

    for (const [compName, config] of Object.entries(SCHEMA)) {
        // Calculate Stride and Offsets
        let stride = 0;
        const fields = [];

        for (const [fieldName, fieldConfig] of Object.entries(config.fields)) {
            const typeInfo = TYPE_MAP[fieldConfig.type];
            if (!typeInfo) {
                console.error(`Unknown type: ${fieldConfig.type} in ${compName}.${fieldName}`);
                continue;
            }
            fields.push({
                name: fieldName,
                type: fieldConfig.type,
                offset: stride,
                bytes: typeInfo.bytes,
                typeInfo: typeInfo,
                default: fieldConfig.default
            });
            stride += typeInfo.bytes;
        }

        // Align stride to 4 bytes for WASM/SIMD compatibility
        if (stride % 4 !== 0) stride += (4 - (stride % 4));

        componentMeta.push({ name: compName, id: config.id, stride, fields });

        // --- WorldState: Add buffer properties ---
        worldStateCode += `    public readonly ${compName.toLowerCase()}: Float32Array;\n`;
        worldStateCode += `    public readonly ${compName.toLowerCase()}Buffer: ArrayBuffer;\n`;
        worldStateCode += `    public readonly ${compName.toLowerCase()}View: DataView;\n`;

        // --- Accessor Class ---
        const lowerName = compName.toLowerCase();
        accessorCode += `// =============================================================================
// ${compName.toUpperCase()} ACCESSOR
// =============================================================================

export class ${compName}Access {
    static readonly STRIDE = ${stride};
    static readonly COMPONENT_ID = ${config.id};
    
    // Field Offsets (bytes)
${fields.map(f => `    static readonly ${f.name.toUpperCase()} = ${f.offset};`).join('\n')}

    /**
     * Set all fields at once (optimized)
     */
    static set(world: WorldState, id: number, ${fields.filter(f => !f.name.startsWith('_')).map(f => `${f.name}: number`).join(', ')}): void {
        const view = world.${lowerName}View;
        const ptr = id * ${stride};
${fields.filter(f => !f.name.startsWith('_')).map(f => `        view.${f.typeInfo.set}(ptr + ${f.offset}, ${f.name}, true);`).join('\n')}
    }
    
    // Individual Getters
${fields.filter(f => !f.name.startsWith('_')).map(f => `    static get${capitalize(f.name)}(world: WorldState, id: number): number {
        return world.${lowerName}View.${f.typeInfo.view}(id * ${stride} + ${f.offset}, true);
    }`).join('\n\n')}

    // Individual Setters
${fields.filter(f => !f.name.startsWith('_')).map(f => `    static set${capitalize(f.name)}(world: WorldState, id: number, value: number): void {
        world.${lowerName}View.${f.typeInfo.set}(id * ${stride} + ${f.offset}, value, true);
    }`).join('\n\n')}
}

`;

        // --- Network Packer Logic ---
        packerCode += `    ${compName.toUpperCase()}: ${config.id},\n`;

        packerBody += `            case ${config.id}: { // ${compName}\n`;
        packerBody += `                const srcView = world.${lowerName}View;\n`;
        packerBody += `                const ptr = id * ${stride};\n`;
        for (const f of fields) {
            packerBody += `                view.${f.typeInfo.set}(offset, srcView.${f.typeInfo.view}(ptr + ${f.offset}, true), true); offset += ${f.bytes};\n`;
        }
        packerBody += `                return offset;\n`;
        packerBody += `            }\n`;

        // --- Network Unpacker Logic ---
        unpackerBody += `            case ${config.id}: { // ${compName}\n`;
        unpackerBody += `                const dstView = world.${lowerName}View;\n`;
        unpackerBody += `                const ptr = id * ${stride};\n`;
        for (const f of fields) {
            unpackerBody += `                dstView.${f.typeInfo.set}(ptr + ${f.offset}, view.${f.typeInfo.view}(offset, true), true); offset += ${f.bytes};\n`;
        }
        unpackerBody += `                return offset;\n`;
        unpackerBody += `            }\n`;
    }

    // =========================================================================
    // FINALIZE WORLD STATE
    // =========================================================================
    worldStateCode += `
    constructor(config?: IWorldConfig) {
        this.maxEntities = config?.maxEntities ?? MAX_ENTITIES;
        
        // Allocate State Flags (1 byte per entity)
        this.stateFlags = new Uint8Array(this.maxEntities);
        
        // Allocate Component Buffers
`;
    for (const meta of componentMeta) {
        const lowerName = meta.name.toLowerCase();
        // Stride in floats (bytes / 4) for Float32Array indexing
        const strideFloats = meta.stride / 4;
        worldStateCode += `        this.${lowerName}Buffer = new ArrayBuffer(this.maxEntities * ${meta.stride});\n`;
        worldStateCode += `        this.${lowerName} = new Float32Array(this.${lowerName}Buffer);\n`;
        worldStateCode += `        this.${lowerName}View = new DataView(this.${lowerName}Buffer);\n`;
    }
    worldStateCode += `    }

    /**
     * Reset all component data to zero
     */
    reset(): void {
        this.stateFlags.fill(0);
`;
    for (const meta of componentMeta) {
        worldStateCode += `        this.${meta.name.toLowerCase()}.fill(0);\n`;
    }
    worldStateCode += `    }

    /**
     * Check if entity ID is valid
     */
    isValidEntityId(id: number): boolean {
        return id >= 0 && id < this.maxEntities;
    }
}

// STRIDES in floats (for array indexing, not bytes)
export const STRIDES = {
`;
    for (const meta of componentMeta) {
        const strideFloats = meta.stride / 4;
        worldStateCode += `    ${meta.name.toUpperCase()}: ${strideFloats},\n`;
    }
    worldStateCode += `} as const;

/**
 * Default global WorldState instance.
 * Used for backward compatibility with static Store classes.
 * @deprecated Prefer injecting WorldState instances for new code.
 */
export const defaultWorld = new WorldState();
`;

    // =========================================================================
    // NETWORK PACKER (SERIALIZER)
    // =========================================================================
    packerCode += `} as const;
    
export const COMPONENT_STRIDES = {
`;
    for (const meta of componentMeta) {
        packerCode += `    ${meta.name.toUpperCase()}: ${meta.stride},\n`;
    }
    packerCode += `} as const;
`;
    packerCode += packerBody;
    packerCode += `            default: return offset;\n        }\n    }\n}\n`;

    // =========================================================================
    // NETWORK DESERIALIZER
    // =========================================================================
    let deserializerCode = `/**
 * AUTO-GENERATED by EIDOLON-V GENESIS - DO NOT EDIT MANUALLY
 * Generated: ${timestamp}
 */

import type { WorldState } from './WorldState';

export class NetworkDeserializer {
    /**
     * Deserialize a single entity's component from a DataView
     * @returns New offset after reading
     */
    static deserializeComponent(
        world: WorldState, 
        id: number, 
        componentId: number, 
        view: DataView, 
        offset: number
    ): number {
        switch (componentId) {
`;
    deserializerCode += unpackerBody;
    deserializerCode += `            default: return offset;\n        }\n    }\n}\n`;

    // =========================================================================
    // WRITE FILES
    // =========================================================================
    fs.writeFileSync(path.join(OUTPUT_DIR, 'WorldState.ts'), worldStateCode);
    fs.writeFileSync(path.join(OUTPUT_DIR, 'ComponentAccessors.ts'), accessorCode);
    fs.writeFileSync(path.join(OUTPUT_DIR, 'NetworkPacker.ts'), packerCode);
    fs.writeFileSync(path.join(OUTPUT_DIR, 'NetworkDeserializer.ts'), deserializerCode);

    // Generate index.ts for easy imports
    const indexCode = `/**
 * AUTO-GENERATED by EIDOLON-V GENESIS
 * Generated: ${timestamp}
 */

export { WorldState, MAX_ENTITIES, STRIDES, defaultWorld, type IWorldConfig } from './WorldState';
export * from './ComponentAccessors';
export { NetworkSerializer, COMPONENT_IDS, COMPONENT_STRIDES } from './NetworkPacker';
export { NetworkDeserializer } from './NetworkDeserializer';
`;
    fs.writeFileSync(path.join(OUTPUT_DIR, 'index.ts'), indexCode);

    console.log('âœ… Generated WorldState.ts');
    console.log('âœ… Generated ComponentAccessors.ts');
    console.log('âœ… Generated NetworkPacker.ts');
    console.log('âœ… Generated NetworkDeserializer.ts');
    console.log('âœ… Generated index.ts');
    console.log(`ğŸ“ Output: ${OUTPUT_DIR}`);
    console.log('ğŸš€ EIDOLON SYSTEM READY.');
}

generate();
